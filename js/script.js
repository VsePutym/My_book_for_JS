//! Асинхронный JavaScript Promise

//!Контекст выполнения, асинхронное выполнение, стек вызовов и event loop
//* в debugger; тоже самое что и консоль разработчика попадает функция в call Stack - это структура данных которая хранит в себе инф. где в программе мы сейчас нах.
//* как только мы начинаем выполнять функцию она попадает в call stack, как только мы выходим , она от туда уберается
//* и в стек функции могут добовлятся только сверху и убераться тоже только с сверху.
//* асинхронное выполнение задач , это когда у нас есть сет таймаут с задержкой и проходит это всё дело по принципу 
//*  1)все задачи попадают в call Stack 
//*  2) всё что имеет таймер отправляется в web Api , остальное выполняется
//*  3) потом из web api все задачи с таймером отправляются в очередь задач 
//*  4) и event looop перетаскивает все эти задачи в call stack если call stack свободен 

// const foo1 =()=>{
//     console.log('загрузить бельё в стиральную машину');
//     foo2(foo3);
// }

// const foo2 =(callback) => {
//     setTimeout(() =>{
//         console.log('закончилась стирка');
//         callback();
//     },2000)
// };

// const foo3 = () => {
//     console.log('развесить бельё');
// }
// foo1();

//! Promise

//*  промисы это обещания 
//* иногда мы хотим сделать что-то после того как произойдёт какое-то событие или не произойдёт 

//* студент хочет попасть в универ, и чтобы ему туда попасть нужно подать документы
// const doUniversity = (docs, resolve, reject) => {//? аргумент принимает документы , ананимную функцию которая выводит принят и reject - отказ
//     if(docs){
//         console.log('рассмотрение документов...');
//         setTimeout(() => {
//             if(Math.random() > 0.3){
//                 let result = 'принят в универ';
//                 resolve(result);
//             }else{
//                 reject('отказано');
//             }
//         }, 3000);
//     }else{
//         reject('отказано не хватает документов');
//     }

// };

// const doArmy = (docs, resolve, reject) =>{
//     if(docs){
//         console.log('военком думает...');
//         setTimeout(()=>{
//             if(docs === 'принят в универ'){
//                 resolve('отсрочка');
//             }else{
//                 reject('повестка');
//             }
//         }, 2000)
//     }else{
//         reject('Повестка');
//     }
// };

// const doWork = (docs, resolve, reject) =>{
//     console.log('Директор google думает....');
//     setTimeout(()=>{
//         if(Math.random() > 0.3){
//             let result = 'приглашён на собиседование в понидельник';
//             resolve(result);
//         }else{
//             reject('отказано вали в яндекс');
//         }
//     })
// };

// const documents = ['паспорт', 'аттестат'];

// //? всё что ниже является работы без промисов 
// doUniversity(documents, (result) => {
//     console.log(result);
//     doArmy(result, (militaryDocs) => {
//         console.log(militaryDocs);//? положительный ответ отсрочка
//         //* после милитаридокс пишем ещё функции т.к мы ожидаем ответа от них
//         doWork(militaryDocs, (data)=>{ //? передаём документы 
//             console.log(data); //? положительный ответ когда прийти на собес
//         }, (reason) => {
//             console.error(reason); //? отрицательный ответ
//         });  
//     }, (reason) =>{
//         console.error(reason);//? отрицательный ответ
//     });
// },(reason) => {
//     console.error(reason);//? отрицательный ответ
// });

//! повторим код который выше только с промисом 
//* для начало мы создадим создадим переменную промис в  doUniversity() и присвоем ей функцию конструктор, которая так и называется промис
//* 

const doUniversity = (docs) => { //? аргумент принимает документы , ананимную функцию которая выводит принят и reject - отказ

    //? эта функция принимает в качестве параметров тоже функцию, её называют executor или выполнитель обещаний 
    //? эта функция которая будет предпринимать действия чтобы вернуть результат , что-то в ней будет происходить и после этого будет возвращаться результат вы-
    //? полнения обещания 
    //? эта функция принимает 2 параметра resolve и reject , это функции сигнализаторы выполнения обещания 
    //? сама функция doUniversity будет возвращать наш Promise
    const promise = new Promise((resolve, reject) => {
        if (docs) { //! Docs = отсрочка
            console.log('рассмотрение документов...');
            setTimeout(() => {
                if (Math.random() > 0.4) {
                    let result = 'принят в универ';
                    resolve(result); //! если она отрабатывает то выполняется .then(1-ая функция) переревод слова resolve - разрешить, решение
                } else {
                    reject('отказано'); //! если она отрабатывает то выполняется .then(2-ая функция)
                }
            }, 3000);
        } else {
            reject('отказано не хватает документов'); //? перевод слова reject - отклонять 
        }
    });

    return promise;

};

//! можно не создавать переменную промис , а сразу прописать return смотреть различия тут и выше
const doArmy = (docs) => { //! Docs = отсрочка
    return new Promise((resolve, reject) => {
        if (docs) { //! Docs = отсрочка
            console.log('военком думает...');
            setTimeout(() => {
                if (docs === 'принят в универ') {
                    resolve('отсрочка'); //? переревод слова resolve - разрешить, решение
                    console.log('отсрочка');
                } else {
                    reject('повестка'); //? перевод слова reject - отклонять 
                }
            }, 2000)
        } else {
            reject('Повестка'); //? перевод слова reject - отклонять 
        }
    });
};

const doWork = (docs) => { //! Docs = отсрочка
    return new Promise((resolve, reject) => {
        console.log('Директор google думает....');
        console.log('Документы от военкомата:' + docs);
        setTimeout(() => {
            if (Math.random() > 0.3) {
                let result = 'приглашён на собиседование в понидельник';
                console.log(result);
                resolve(result); //? переревод слова resolve - разрешить, решение
            } else {
                reject('отказано вали в яндекс'); //? перевод слова reject - отклонять 
            }
        }, 3000);
    });
};

const documents = ['паспорт', 'аттестат'];

//* чтобы принять промис , наши resolve, reject , нам неоодимо воспользоваться воспользоваться методами промисов
//* 1) метод then(); этот метод обрабатывает последствия нашего обещания , тоесть что будет происходить если обещание выполниться или не выполнится 
//? в качестве параметров then принимает 2 функции: 1) выполняется если обещание выполнено успешно, тоесть resolve 2) отрицательно reject 
//! первая функция отработает после выполнения функции resolve а вторая если вызывится reject 
// doUniversity(documents)
// .then((result)=>{
//     console.log(result);
//     return result; //? таким образом docs передаётся в doArmy , docs является let result = 'принят в универ'; а потом они же и передаются в doWork
// }, (reason)=>{
//     console.log(reason);
// })
// .then(doArmy)
// .then(doWork);

//? после первого then мы можем написать ещё then это наз. ципочка then
//? он будет выполнен если первый then был успешным
//* метод catch, если от любой из функций , будь то университи арми или ворк верн1м нам отрицательный промис то отработает catch, а все остальные then не отработают

// doUniversity(documents)
//     .then((result) => {
//         console.log(result);
//         return result; //? таким образом docs передаётся в doArmy , docs является let result = 'принят в универ'; а потом они же и передаются в doWork
//     })
//     .then(doArmy)
//     .then(doWork)
//     .catch((reason) => {
//         console.log(reason); //? перевод слова reason - причина;
//     })
//     //* после catch мы напишем ещё один then и он отработает в любом случае  и обязательно он должен идти после catch 
//     .then(() => {
//         console.log('выполнится  в любом случае');
//     })

//* иногда требуется дождаться пока выполнятся все промисы

const doWorking = (company) =>{ //! эта функция будет моделировать ответы от компаний 
    return new Promise((resolve, reject) =>{
        const time = Math.ceil(Math.random() * 3000); //? чтобы ответ компаний генерировался в разное время
        setTimeout(()=>{
            if(time % 15){
                resolve(company);
            }else{
                reject(company);
            }
        }, time);
    });
};

const hh = doWorking('HH');
const google = doWorking('google');
const yandex = doWorking('yandex');
const ozon = doWorking('ozon');
const picabu = doWorking('picabu');

//* у промиса есть такой метод all, промис будет дожидаться ответа от всех вызванных промисов, в качестве параметров принимает массив с нашими обещаниями

Promise.all([hh, google, yandex, ozon, picabu])
    .then(result => console.log(`тебя пригласисли  на собес в ${result}`))
    .catch(result =>{
        console.log(`Компания: ${result} отказала`);
    })
//* есть метод race() он дождиается выполнения первого промиса, тоесть тот который первый выполнится тот и попадёт в then
// Promise.race([hh, google, yandex, ozon, picabu])
//     .then(result => console.log(`тебя пригласисли  на собес в ${result}`))
//     .catch(result =>{
//         console.log(`Компания: ${result} отказала`);
//     })
//! then отработает когда все промисы будут положительные 
//! в реальной жизни мы делаем запрос на несколько серверов и только когда вернулся ответ от каждого сервера, к примеру где-то мы получили картинку,
//! где-то текст, где-то видео и когда нам все результаты вернулись , нам необходимо показать результаты на странице то поможет промис.all
//! или к примеру мы хотим чтобы видео прилето позже как загрузиться так прилетит , а картинку или текст сразу то мы пишем 
Promise.all([img, text])
 
.//! а видео в другом промисе 